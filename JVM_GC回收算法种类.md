﻿## Blog 
``` http 
https://www.2cto.com/kf/201608/539439.html  JVM垃圾收集器----垃圾标记、回收算法 
```
# 回收算法种类
## 引用计数法
统计对象的引用，当一个对象的引用为0时，则代表这个对象是一个可被回收的。java没有使用这种算法，因为效率低下。
## 标记清除法
标记清除法是现代回收算法的基础，它把回收分为了两个阶段，先从根开始出发，对每一个可达的对象进标记。清除阶段对没有标记的对象，即可回收对象进行回收。标记清除最大的问题是内存会呈现碎片化，可能导致明明内存空间是足够的，但是无法创建大对象。
## 标记压缩法
标记压缩算法是标记清除算法的一种改进，它分为三个阶段，和标记清除一样，先需要标记每一个可达的对象，然后把存活对象压缩到最左侧，然后一次性清除边界外的所有内存空间。标记压缩解决了标记清除法内存碎片化的问题。
## 复制回收法
复制回收法的思想是把内存分为两块，每次只使用一块内存，在做回收的时候，把存活对象复制到未使用的内存区间中，然后交换内存角色。复制有点事速度快，缺点是浪费内存严重。
## 分代收集算法
采用不同算法处理[存放和回收]Java瞬时对象和长久对象。大部分Java对象都是瞬时对象，朝生夕灭，存活很短暂，通常存放在Young新生代，采用复制算法对新生代进行垃圾回收。老年代对象的生命周期一般都比较长，极端情况下会和JVM生命周期保持一致；通常采用标记-压缩算法对老年代进行垃圾回收。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。相对于年老代，通常年轻代要小很多，回收的频率高，速度快。年老代则回收频率低，耗时长。内存在年轻代里面分配，年轻代里面的对象经过多个回收周期依然存活的会自动晋升到年老代。

# 内存模型解释
## JVM内存分配详情   jdk1.8  
Heap 即是堆空间
堆空间可以分为两块
YoungGen / OldGen   即 新生代/老年代

### 新生代
新生存代又可以把内存分为Eden 和 form/to
新生代都是占用内存较小且生命周期较短的对象。
#### eden
eden是对象创建的地方，所有对象从这里被开辟内存空间。
#### form -> to 
form/to两个内存大小完全一模一样，因为他们是采用的复制算法。
### 老年代
老年代存放的都是生命周期较长，且内存占用非常大的对象，老年代使用的是标记压缩算法。

### 可触及性
也可以叫做可达性。
虚拟机从根开始追踪对象，如果对象是可达的，那么证明这个对象是存活的。
#### finalize
虚拟机在回收这个对象的时候，会调用一次finalize方法，但是在对象的生命周期中，这个方法只会被调用一次。
#### 根
栈中引入的对象
全局对象，即静态对象
JNI方法栈对象

### 全局停顿  Stop-The-world
所有java代码停止，但还有native代码可以执行，但是不能和jvm交互
一般是由代码gc导致的,线程死锁也有可能。
#### FullGC 全局gc 
全局gc是一个Java虚拟机停止所有操作，对内存进行回收的机制。

